# In a new file, e.g., llg_solver/solution.py

# In your llg_solver/solution.py file

import numpy as np
import copy
import math

# Import Plotly for interactive visualizations
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

class Solution:
    """
    Solution of an LLG model defined by a Model object.
    This object is generated by model.solve_LLG().
    Uses Plotly for interactive plotting.

    Attributes:
        model (Model): A deep copy of the model used for the simulation.
        t (np.ndarray): 1D array of time points.
        M (np.ndarray): 3D array of magnetic moments, shape (time_points, n_mag, 3).
        E (list[dict]): Lazily-computed energy evolution; list of dictionaries per timestep.
        M_total (np.ndarray): Lazily-computed net magnetic moment, shape (time_points, 3).
    """

    def __init__(self, model, t, y):
        """
        Initializes the Solution object.
        """
        self.model = copy.deepcopy(model)
        self.t = t
        self.M = y  # store magnetic moments as M, not y
        self.E = None
        self.M_total = None

    def append(self, other_solution):
        """
        Appends another solution to this one.
        """
        if self.t[-1] > other_solution.t[0]:
            raise ValueError(
                "The start time of the appended solution must be after the end time of the original solution.")

        start_index = 0
        # Update the attribute M instead of y
        if np.isclose(self.t[-1], other_solution.t[0]):
            if np.allclose(self.M[-1, :, :], other_solution.M[0, :, :]):
                start_index = 1
            else:
                raise ValueError("Solutions have an overlapping time point but different magnetic states.")

        self.t = np.concatenate((self.t, other_solution.t[start_index:]))
        self.M = np.concatenate((self.M, other_solution.M[start_index:, :, :]), axis=0)

    def plot(self):
        """
        Plots the x, y, z components of each magnetic moment over time using Plotly.

        A single, unified legend is created. Clicking a legend item (e.g., 'Mx')
        will toggle the visibility of that component across ALL subplots simultaneously.
        """
        n_mag = self.model.n_mag
        n_cols = math.ceil(math.sqrt(n_mag))
        n_rows = math.ceil(n_mag / n_cols)

        subplot_titles = [f'Moment {i + 1}' for i in range(n_mag)]
        fig = make_subplots(rows=n_rows, cols=n_cols, subplot_titles=subplot_titles)

        time_ns = self.t # Convert time to nanoseconds for plotting

        # Define consistent colors and names for the components
        component_names = ['Mx', 'My', 'Mz']
        component_colors = px.colors.qualitative.Plotly

        for i in range(n_mag):  # Loop over each magnetic moment
            row = i // n_cols + 1
            col = i % n_cols + 1

            for j in range(3):  # Loop over the three components (x, y, z)
                fig.add_trace(
                    go.Scatter(
                        x=time_ns,
                        y=self.M[:, i, j],
                        # KEY 1: All 'x' traces share the name 'Mx', all 'y' share 'My', etc.
                        name=component_names[j],
                        # Assign a consistent color based on the component type
                        line=dict(color=component_colors[j]),
                        # KEY 2: Only show the legend for the first moment's traces
                        showlegend=(i == 0)
                    ),
                    row=row,
                    col=col
                )

        # Update layout for a clean, professional look
        fig.update_layout(
            title_text='Magnetic Moment Evolution',
            height=n_rows * 300,  # Adjust height based on number of rows
            width=n_cols * 450 + 150,  # Add a little extra width for the legend
            template='plotly_white',
        )

        # Update all axes labels
        fig.update_xaxes(title_text='Time (ns)')
        fig.update_yaxes(title_text='Magnetization')

        fig.show()

    def calculate_energy(self):
        """Calculates the energy evolution for each time step."""
        if self.E is None:
            num_steps = len(self.t)
            energies = []
            for i in range(num_steps):
                energies.append(self.model.energy(self.t[i], self.M[i, :, :]))
            self.E = energies

    def plot_energy(self):
        """Plots the total energy and its individual contributions over time using Plotly."""
        self.calculate_energy()

        fig = go.Figure()
        time_ns = self.t
        # Determine all keys present across timesteps (excluding 'total' which we'll plot first)
        all_keys = set()
        for e in self.E:
            all_keys.update(e.keys())
        keys = [k for k in sorted(all_keys) if k != 'total']

        # Plot total first
        fig.add_trace(go.Scatter(x=time_ns, y=[e.get('total', float('nan')) for e in self.E], name='Total', mode='lines'))
        # Plot individual contributions
        for key in keys:
            fig.add_trace(go.Scatter(x=time_ns, y=[e.get(key, 0.0) for e in self.E], name=key.capitalize(), mode='lines'))

        fig.update_layout(
            title_text='Energy Evolution',
            xaxis_title='Time (ns)',
            yaxis_title='Energy (eV)',
            legend_title='Energy Components',
            template='plotly_white'
        )
        fig.show()

    def calculate_M_total(self):
        """Calculates the net magnetic moment over time."""
        if self.M_total is None:
            self.M_total = np.sum(self.M, axis=1)

    def plot_M_total(self):
        """Plots the total (net) magnetic moment of the system over time using Plotly."""
        self.calculate_M_total()

        fig = go.Figure()
        time_ns = self.t
        labels = ['M_total_x', 'M_total_y', 'M_total_z']

        for i, label in enumerate(labels):
            fig.add_trace(go.Scatter(x=time_ns, y=self.M_total[:, i], name=label, mode='lines'))

        fig.update_layout(
            title_text='Total Magnetic Moment',
            xaxis_title='Time (ns)',
            yaxis_title='Net Magnetization',
            legend_title='Components',
            template='plotly_white'
        )
        fig.show()

    def plot_animated_3d(self, max_frames=200, arrow_scale=1.0, colors=None):
        """
        Creates an interactive 3D animated plot of the magnetic moments over time.

        The user's camera orientation and zoom are preserved during animation.
        """
        # 1. --- Data Preparation ---
        total_steps = len(self.t)
        if total_steps > max_frames:
            indices = np.linspace(0, total_steps - 1, max_frames, dtype=int)
            t_anim = self.t[indices]
            M_anim = self.M[indices, :, :]
        else:
            t_anim = self.t
            M_anim = self.M

        n_mag = self.model.n_mag
        num_frames = len(t_anim)

        if colors is None:
            colors = px.colors.qualitative.Plotly

        # 2. --- Create the Initial Figure (Frame 0) ---
        initial_traces = []
        for i in range(n_mag):
            color = colors[i % len(colors)]
            moment_colorscale = [[0, color], [1, color]]
            trace = go.Cone(
                x=[0], y=[0], z=[0],
                u=[M_anim[0, i, 0] * arrow_scale],
                v=[M_anim[0, i, 1] * arrow_scale],
                w=[M_anim[0, i, 2] * arrow_scale],
                name=f'Moment {i + 1}',
                colorscale=moment_colorscale,
                sizemode="absolute",
                showscale=False
            )
            initial_traces.append(trace)

        fig = go.Figure(data=initial_traces)

        # 3. --- Create Animation Frames ---
        frames = []
        for k in range(num_frames):
            frame_data = []
            for i in range(n_mag):
                frame_data.append(go.Cone(
                    u=[M_anim[k, i, 0] * arrow_scale],
                    v=[M_anim[k, i, 1] * arrow_scale],
                    w=[M_anim[k, i, 2] * arrow_scale]
                ))
            frame = go.Frame(data=frame_data, name=str(t_anim[k]))
            frames.append(frame)

        fig.frames = frames

        # 4. --- Configure Animation Controls (Slider and Buttons) ---
        play_button = dict(label="Play", method="animate", args=[None, dict(mode="immediate", fromcurrent=True,
                                                                            frame=dict(duration=100, redraw=True),
                                                                            transition=dict(duration=0))])
        pause_button = dict(label="Pause", method="animate", args=[[None], dict(mode="immediate",
                                                                                frame=dict(duration=0, redraw=False),
                                                                                transition=dict(duration=0))])

        def create_slider_steps():
            steps = []
            for i in range(num_frames):
                step = dict(method="animate", args=[[str(t_anim[i])],
                                                    dict(mode="immediate", frame=dict(duration=50, redraw=True),
                                                         transition=dict(duration=0))],
                            label=f"{t_anim[i] :.2f}")
                steps.append(step)
            return steps

        fig.update_layout(
            updatemenus=[
                dict(type="buttons", buttons=[play_button, pause_button], direction="left", pad=dict(r=10, t=87),
                     showactive=False, x=0.1, xanchor="right", y=0, yanchor="top")],
            sliders=[dict(active=0, steps=create_slider_steps(), yanchor="top", xanchor="left",
                          currentvalue=dict(font=dict(size=16), prefix="Time: ", visible=True, xanchor="right"),
                          pad=dict(b=10, t=50), len=0.9, x=0.1, y=0)]
        )

        # 5. --- Configure 3D Scene Layout ---
        max_range = np.max(np.abs(self.M)) * arrow_scale * 1.1
        fig.update_layout(
            title="3D Animated Evolution of Magnetic Moments",
            scene=dict(
                xaxis=dict(range=[-max_range, max_range], autorange=False, title="Mx"),
                yaxis=dict(range=[-max_range, max_range], autorange=False, title="My"),
                zaxis=dict(range=[-max_range, max_range], autorange=False, title="Mz"),
                aspectmode='cube',
                # --- THIS IS THE CORRECT LOCATION FOR UIREVISION ---
                # It locks the camera state of the 3D scene.
                uirevision='camera_and_zoom_lock'
            ),
            template='plotly_white',
            legend_title_text='Moments'
        )

        fig.show()
